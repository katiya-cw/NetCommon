
当前剩余钱数地址：0x0010(三位整数一位小数)
5A A5 05 82 0010 0001  显示  0.1元
5A A5 05 82 0010 0010  显示  1.6元

当前已用钱数地址：0x0020(三位整数一位小数)
5A A5 05 82 0020 0001  显示  0.1元
5A A5 05 82 0020 00FF  显示  25.5元

上线状态图标地址：0x0030   (赋值0离线，赋值1在线，上电默认0)
5A A5 05 82 0030 0000	离线
5A A5 05 82 0030 0001	在线

出错代码地址：0x0050
5A A5 0A 82 0050 45 72 72 6F 72 FF FF (显示Error)
5A A5 0A 82 0050 20 20 20 20 20 FF FF (显示清空)

手机号地址：0x0100
5A A5 04 83 0100 06 （手机号11位数字，读6个字）
返回数据：5A A5 10 83 01 00 06 31 38 39 32 35 32 35 31 39 30 37 FF 

密码地址：0x0200
5A A5 04 83 0200 02 （读2个字数据，4位）

确认地址：0x0300
5A A5 06 83 03 00 01 00 01 （点击确认后返回数据）

如果主板检测输入错误：发送5A A5 03 80 4F 01 弹出密码错误弹窗




问题：
剩余钱数和已用钱数都是2位小数显示，剩余钱数最大99999.00
已用钱数最大99.00

如果显示Error08或者显示Error39如何发命令，请举例
密码是6位，不是4位，请给修改一下
还有你不是要做2个不同的工程吗，为什么只做了1个?
当前剩余钱数地址：0x0010(五位整数两位小数)  数据4字节

5A A5 07 82 0010 00 98 96 1C 显示99999.00
输入4字节范围 00 00 00 00 ~ 00 98 96 1C对应0~99999.00元


当前已用钱数地址：0x0020(两位整数两位小数)  数据2字节

5A A5 05 82 0020 0001  显示  0.01元
5A A5 05 82 0020 00FF  显示  2.55元
5A A5 05 82 0020 26AC  显示  99.00元


密码地址：0x0200
5A A5 04 83 0200 03 （读3个字数据，6位）

出错代码地址：0x0050
5A A5 0C 82 0050 45 72 72 6F 72 30 38 FF FF(显示Error08)
5A A5 0C 82 0050 45 72 72 6F 72 33 39 FF FF(显示Error39)
5A A5 0C 82 0050 20 20 20 20 20 20 20 FF FF (显示清空)
//////////////////////////////////////
注意四种情况下的结算：
1，按键
2，缺水
3，时间到
4，钱数不够 


刷卡上传：68 01 20 06 08 29 89 32 23 79 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 59 D9 16
上位机回传的会员余额： 68 01 20 04 08 55 BD 01 01 00 00 00 06 00 04 46 00 00 32 00 00 00 00 00 00 00 00 00 00 BB 2B 16 
洗车机上传确认收到余额：68 01 20 04 08 00 00 01 00 00 00 00 00 00 00 00 00 00 00 64 00 00 00 00 00 00 07 00 00 7B 74 16 23 
上位机回复结算成功68 01 20 23 08 00 00 00 00 00 01 00 06 00 04 46 00 00 32 00 00 00 00 00 00 00 00 00 00 F4 B2 16 
按键结算：68 01 20 22 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 2D 16
上位机回复结算成功：68 01 20 23 08 00 00 00 00 00 01 00 06 00 04 46 00 00 32 00 00 00 00 00 00 00 00 00 00 F4 B2 16 
缺水报警结算方式：68 01 20 22 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 2D 16
上位机回复结算成功： 68 01 20 23 08 00 00 00 00 00 01 00 06 00 04 46 00 00 32 00 00 00 00 00 00 00 00 00 00 F4 B2 16 

刷卡上传： 68 01 20 55 08 13 56 28 23 25 60 12 34 56 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3C 09 16 
上位机回传的会员余额：68 01 20 04 08 4A BD 01 01 00 00 00 06 00 04 46 00 00 32 00 00 00 00 00 00 00 00 00 00 07 7E 16 
洗车机上传确认收到余额：68 01 20 04 08 00 00 01 00 00 00 00 00 00 00 00 00 00 00 64 00 00 00 00 00 00 07 00 00 7B 74 16
 
 
 
 
 
 
 
  /////////////////////////////////////////////////////
 unsigned char CfgEU(unsigned char val_numb,unsigned int val_bps,unsigned char val_bit,unsigned char val_parity)
{
。。。。。。。。。。。。。。。 
			case 9600:
			temp1 = 0xeb;
			temp2 = 0; 、、&&&&&&&&&&&注意这里必须改成0，否则无法9600通讯
			break;	// T1M = 1,SMOD = 1;
	、//////////////////////////////////
V4.2:
 ///////////////////////////////////////////
 
  //-----为了满足测量AD的时候电就不准的毛病，特意如下修改，但这样就主频就改成了13MHZ，系统原来实际是6.4MHZ

   最后决定对下面的进行微调成6.4MHZ,改2个地方即可：
    1，	V98XX_SetPLL_Fast(4);改成V98XX_SetPLL_Fast(3);
	2，波特率的设置不用修改啦


exligreg.h:
sbit PMG		= SysCtrl^4;
//sbit PLLLCK		= SysCtrl^7;&&&&&&&&&&&
sbit FSC       = SysCtrl^5;//bit5	FSC	0	快速休眠控制位	0，关闭；1，开启

添加：
#define CtrlCry0       XBYTE[0X285F]    //晶振微调       &&&&&&&&&&&
#define CtrlCry1       XBYTE[0x2860]   //起振电容调节 &&&&&&&&&&&
#define CtrlCry2       XBYTE[0x2861]   //晶振调节&&&&&&&&&&&
sfr PLLLCK =0xa3;

MAIN.C:

把下面的改为
void main()
{	 uint8 dispflashtime,waketime; 
extern  void led_Data3(unsigned  long    tempN)	;
//extern void SetPLL(unsigned char val_para);
tt121:	 
	FSC=0; //快速休眠控制，0关闭
	FWC=1;//快速唤醒1开启，0关闭
	MCUFRQ=1;//电能计量模块时钟源，1选择PLL时钟，0选择OSC时钟
//	SetPLL(SETPLL_6_4M);  //单步调试（F11）此函数会失去调试连接
//  SetPLL(SETPLL_3_2M); //改成和V9401一样的速度   
	CtrlPLL = 0X40;	   //MCU 13M
//	Flash_LowPowerConsum();//设置FLASH低功耗模式
//	SetRTCInt(RTC_DAY);//设置1天唤醒
	
	CtrlADC6 =0x0f ;//开启四个ADC通道

改成：
	tempqq=V98XX_SetPLL_Fast(4);
	if(tempqq==0)
		goto   tt121;
	
	CtrlADC6 =0x0f ;//开启四个ADC通道


 波特率也要改：
 unsigned char CfgEU(unsigned char val_numb,unsigned int val_bps,unsigned char val_bit,unsigned char val_parity)
{
。。。。。。。。。。。。。。。。。。。。。
			temp2 = 1;break;	// T1M = 1,SMOD = 1;				
			case 2400:
			temp1 = 0x55;
			temp2 = 0;break;	// T1M = 1,SMOD = 1;  &&&&&&&改成0 波特率不加倍
			case 4800:
	
//////////////////////////////////////////

  通过下面的地方来调整计时价格比例关系
  unsigned char cunt_pauls(unsigned char *point_cf,unsigned int changshu)
{ unsigned char num;
  #ifdef  DEFMYCHANGSHU
    temp2=*point_cf;
   #ifdef TowLogic
  if(jishiLogic==1)
    {
	changshu=10;   //&&&&&&&&&&&&
	 temp2=temp2;
	}
 1，设置卡价格1.00元，常数100 ，几点方式0  （这里的常数和价格只是影响计流量时的计算）
2，F1:设置电价
   F2:设置刷卡方式最小扣费金额
   F3:设置时间1-24小时
   F4:设置时间的分钟部分0-60
   F5:设置投币方式的扣费金额
   F6:设置M5通道时间价格，是指5分钟使用多少秒，（有时需要乘于10的倍数）
   F7:设置M3通道时间价格，是指5分钟使用多少秒，（有时需要乘于10的倍数）
   F8:设置M6通道时间价格，是指5分钟使用多少秒，（有时需要乘于10的倍数）
   F9:设置M4通道时间价格，是指5分钟使用多少秒，（有时需要乘于10的倍数）
   FA:设置1决定所有通道为计时方式，设置0决定M6,M4为计流量方式。

洗车机主板优点：
     1， 可以分别设置刷卡和投币的最小启动金额
     2， 具备控制加热排空的功能
     3， 智能灯功能，白天刷卡不亮，晚上刷卡会亮，并且刷卡结束时会延迟30秒左右才灭。
     4， 具有微信支付和支付宝支付功能。
     5,  5W大喇叭，语音高于市面上现有产品，语音大小还可以调整。
     6， 具备短信遥控和短信上报数据功能
     7,  共6个通道，其中前4个是40A大继电器，可以省去交流接触器，直接控制电机。节约成本。
     8， 具有液晶接口（1-10寸彩色屏都可以直接使用），可以大屏显示。
     9， 具有超级大的板载容量30M字节，可以进行记录查询。
     10，时钟使用国际最好的进口芯片，保证1年的误差在2分钟内，几年都不需要校正板子上的时间。
     11，按键比较大，操作手感舒服。
     12，板载数码管和外接数码管双显示，方便调试。
     13，板载2路模拟量接口，可以测量温度，压力等数据，进行逻辑判断。
     14，板上每个继电器动作都有LED灯指示。
     15，板上有联网功能，可以与任何网络进行联网操作。
 //////////////////////////////////////////////////////////////////////////
 /*	  移值W25系列存储器时注意下面几个问题
 static uint8_t SpiFlash_Wait_Busy(void)
{	 
   uint8_t cDelay_Count=5;
    while(((SpiFlash_ReadSR()&SPIFLASH_WRITE_BUSYBIT) == 0X01)&&( cDelay_Count!=0))	//&&&防止程序死机，如果无法处理，立即跳出	
    {  	 cDelay_Count--;
		  ClearWDT(); 
		  mdelay(50);//延时50MS，共延时250MS
      // if(cDelay_Count==100)  //防止程序死机，如果无法处理，立即跳出	&&
       //   break;     
    }
    return RET_SUCCESS;
}
uint16_t SPIFlash_GPIO_GetBit(void)
{
  uint16_t retValue = 0;
  uint16_t valueTemp = 0;
//  valueTemp = P8IN;
 if((P5ID&bBIT3)==bBIT3)   //&&&&&&&&&&改为自己的IO口
  {
  retValue =0x01;            //BIT1即是0x02
  }
 else
    {
  retValue =0x00;            //BIT1即是0x02
  }
  return retValue;
}



*/


 ///////////////////////////////////////////////////////////////////////////

/////////////为了解决485通讯的问题//////////////////////////////////////////////////////
1,	unsigned char CfgEU(unsigned char val_numb,unsigned int val_bps,unsigned char val_bit,unsigned char val_parity)
{
..........................
	if(ucFrqt==0)//50HZ 
	{
		switch(val_bps)
		{
		.............................
		
			case 2400:
			temp1 = 0x55;  //&&&&&&&&&改为0X55通讯就正常啦
			temp2 = 1;break;	// T1M = 1,SMOD = 1;
 2，中断不能接受的原因
		//=================================================
//函数功能：初始化485通讯模块
//
//=================================================
void init_485comm(void)
{ uint8  i;
  unsigned int value;
     ExInt3IE&=(~BIT3); //关闭串口5接收中断   &&&&&&&&777
...................................
//  SetInterrupt(10);                           //打开接收中断
    IE|=BIT7;
  EIE|=BIT1;
  ExInt3IE|=BIT3;	 //打开串口5接收中断   &&&&&&&&&&7
.....................

}
注意  SetInterrupt（）里面的INTERARRYex[]数字有问题，需要更改
const struct INTERARRYEX code INTERARRYex[20] = 
{
0x01,&ExInt2IE,&ExInt2IFG,0x01, // 7
0x01,&ExInt2IE,&ExInt2IFG,0x02, // 8
0x01,&ExInt2IE,&ExInt2IFG,0x04, // 9
0x01,&ExInt2IE,&ExInt2IFG,0x08, // 10
0x01,&ExInt2IE,&ExInt2IFG,0x10, // 11
0x01,&ExInt2IE,&ExInt2IFG,0x20, // 12
0x01,&ExInt2IE,&ExInt2IFG,0x40, // 13
0x01,&ExInt2IE,&ExInt2IFG,0x80, // 14
0x02,&ExInt3IE,&ExInt3IFG,0x01, // 15
0x02,&ExInt3IE,&ExInt3IFG,0x02, // 16
0x02,&ExInt3IE,&ExInt3IFG,0x04, // 17
0x02,&ExInt3IE,&ExInt3IFG,0x08, // 18
0x02,&ExInt3IE,&ExInt3IFG,0x10, // 19
0x02,&ExInt3IE,&ExInt3IFG,0x20, // 20
0x02,&ExInt3IE,&ExInt3IFG,0x40, // 21
0x04,&ExInt4IE,&ExInt4IFG,0x01, // 22
0x04,&ExInt4IE,&ExInt4IFG,0x02, // 23
0x04,&ExInt4IE,&ExInt4IFG,0x04, // 24
0x04,&ExInt4IE,&ExInt4IFG,0x08, // 25
0x04,&ExInt4IE,&ExInt4IFG,0x10 // 26
};
  //////////////////////////////////////////////、/////////////////////////////、、、
 	 unsigned char  SetDataTOrem()
    {  ...................
                     
                   	    //断电标志
                    	//  JIDIANQI=*(point_addr+28);	//&&&&去掉这里，否则会出现掉电又上电的现象
						.....................
 	 }
    V5.92关阀加快版本	 以下2个方法解决

   1，增加了如下函数
   	case  2   : 
				。。。。。。。。。。。。。。。。。。。。
								JIDIANQI=1;	  //不加这个会受getDataTOrem（）的影响，产生误动作
							   getDataTOrem1();//先把所有的数据都读出来	否则已走电量无法刷新&&&&&&&&&&
。。。。。。。。。。。。。。。。。。。。。。。。
   2，加跳转	  if(  ( MYmeterN.UID!=ttemp1)&&(ttemp4==0x22222222) )	//村号不同，跳出
					   {
		    	               	.................
		        
				 GGSYSN.yonghuhao=ttemp2;

	if(GGSYSN.yonghuStatus==2)	 goto  	Status2	;//	如控制器内部是状态2，就直接执行2的回读处理，跳过读出对应数据，防止出错，加快速度&&&&&&&&
	.....................
						case  2   : 
Status2	:				     if(mjflag1!=0) return;    //&&&&&&&77    
。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

	对于74HC164控制的数码管闪烁解决方法：
	用164芯片驱动数码管，多用于IO口资源紧张、数码管显示数据刷新慢的场合。设计电路时，多个164芯片级联使用，
	不管驱动多少位数码管，一共只占用单片机2个IO口，可以说是最省IO口的驱动方式了，并且还是静态驱动，没有
	频闪和亮度低的现象。缺点是，多个164级联使用，会导致单片机刷新显示数据时需要一次性发送大量的显示数据
	（每个数码管1个字节），这个过程中数码管会出现全亮现象，虽然发送数据的过程持续时间很短，但还是影响显
	示效果，建议在刷新数据时关闭数码管。
	用164带LED总会有鬼影存在，只能减轻，无法彻底削除！
以前见过别人接电容的，电路具体怎么接没仔细看，效果会好一点点，但也很有限，而且需要接很多电容
个人建议，
1、74164换成74HC595
2、如果单片机的资源还算富裕，用一个74164，加接6个三极管（或者ULN2003A），做成动态显示的
3、用专用的LED显示驱动芯片，如MAX7219。

我一般都是用动态显示，口线占用多点，但软件开销并不大。
据说MAX7219的可靠性不太好，现在有许多兼容的型号，可以找找看。
  V5.87
     、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
   漏洞！！必须加上下面这句：
   						warining(2);  //报警声
		                GTIMS=0;//注意这个地方必须清0，否则容易出现突然掉电的现象  &&&&&&&&
							if(GGSYSN.AlreadyBuy_Money>GGSYSN.AlreadyUsed_Money)  JIDIANQI=1;
    	                     	if(JIDIANQI	==1)
 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。




		   E2ROM的驱动改为SCL=P5.0 SDA=P4.1
P6.0变成P6.7
P6.1变成P6.6

把24C16的SDA改为P5.1，这样方便和液晶管角共用

把moniI2C里面的：
 bBIT3=BIT0;
         bBIT4=BIT1; 改成
		  bBIT3=BIT1;
         bBIT4=BIT0;

		   times_1s++;
// if(times_1s>15)	 for(;;);
		curent_dispoint=0;	 //必须加，否则容易出现溢出数据乱的错误